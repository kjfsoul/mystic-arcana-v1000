{
  "endpoints": [
    {
      "endpoint": "/api/tarot/draw",
      "method": "POST",
      "description": "Enhanced draw endpoint with AstrologyGuru hybrid readings",
      "code": "import { NextRequest, NextResponse } from 'next/server';\nimport { createClient } from '@/lib/supabase/server';\nimport Logger from '@/utils/logger';\nimport { AstrologyGuruAgent } from '@/src/agents/astrology-guru';\nimport { SwissEphemerisShim } from '@/lib/astrology/SwissEphemerisShim';\n\nexport async function POST(request: NextRequest) {\n  const startTime = Date.now();\n  const logger = new Logger('tarot-api-enhanced');\n\n  try {\n    const body = await request.json();\n    const { \n      spread_type = '3-card', // Changed default to 3-card as requested\n      user_id,\n      deckId = '00000000-0000-0000-0000-000000000001',\n      allowReversed = true,\n      includeAstrology = true, // New: Include astrological insights\n      birthData = null // Optional: User's birth data for personalized readings\n    } = body;\n\n    // Validate spread_type\n    const validSpreads = ['single', '3-card', 'celtic-cross', '5-card', '7-card'];\n    if (!validSpreads.includes(spread_type)) {\n      return NextResponse.json({\n        success: false,\n        error: 'Invalid spread_type. Must be one of: ' + validSpreads.join(', '),\n        code: 'INVALID_SPREAD_TYPE'\n      }, { status: 400 });\n    }\n\n    // Map spread_type to card count\n    const spreadRequirements = {\n      'single': 1,\n      '3-card': 3,\n      '5-card': 5,\n      '7-card': 7,\n      'celtic-cross': 10\n    };\n\n    const requiredCount = spreadRequirements[spread_type];\n\n    // Initialize Supabase\n    const supabase = await createClient();\n\n    // Fetch deck and cards\n    const { data: deckData, error: deckError } = await supabase\n      .from('decks')\n      .select('*')\n      .eq('id', deckId)\n      .eq('is_active', true)\n      .single();\n\n    if (deckError || !deckData) {\n      logger.error('deck_fetch_error', user_id, { deckId }, deckError || undefined, 'Failed to fetch deck');\n      return NextResponse.json({\n        success: false,\n        error: 'Deck not found or inactive',\n        code: 'DECK_NOT_FOUND'\n      }, { status: 404 });\n    }\n\n    const { data: cardData, error: cardError } = await supabase\n      .from('cards')\n      .select('*')\n      .eq('deck_id', deckId)\n      .order('card_number');\n\n    if (cardError || !cardData || cardData.length < requiredCount) {\n      logger.error('cards_fetch_error', user_id, { deckId }, cardError || undefined, 'Insufficient cards');\n      return NextResponse.json({\n        success: false,\n        error: `Insufficient cards. Need ${requiredCount}, have ${cardData?.length || 0}`,\n        code: 'INSUFFICIENT_CARDS'\n      }, { status: 500 });\n    }\n\n    // Fisher-Yates shuffle\n    const deck = [...cardData];\n    for (let i = deck.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [deck[i], deck[j]] = [deck[j], deck[i]];\n    }\n\n    // Position names for different spreads\n    const getPositionName = (spread: string, index: number): string => {\n      const positions = {\n        'single': ['Present Situation'],\n        '3-card': ['Past', 'Present', 'Future'],\n        '5-card': ['Present', 'Past Influences', 'Hidden Influences', 'Advice', 'Likely Outcome'],\n        '7-card': ['Past', 'Present', 'Future', 'Your Approach', 'External Influences', 'Hopes/Fears', 'Outcome'],\n        'celtic-cross': [\n          'Present Situation', 'Challenge/Cross', 'Distant Past',\n          'Recent Past', 'Possible Outcome', 'Immediate Future',\n          'Your Approach', 'External Influences', 'Inner Feelings', 'Final Outcome'\n        ]\n      };\n      return positions[spread]?.[index] || `Position ${index + 1}`;\n    };\n\n    // Draw cards with position and reversal\n    const drawnCards = deck.slice(0, requiredCount).map((card, index) => {\n      const isReversed = allowReversed && Math.random() < 0.3;\n      return {\n        id: card.id,\n        name: card.name,\n        suit: card.suit,\n        arcana_type: card.arcana_type,\n        card_number: card.card_number,\n        image_url: card.image_url,\n        meaning_upright: card.meaning_upright,\n        meaning_reversed: card.meaning_reversed,\n        keywords: card.keywords,\n        position: getPositionName(spread_type, index),\n        positionIndex: index,\n        isReversed,\n        description: card.description || '',\n        elemental_association: card.elemental_association,\n        astrological_association: card.astrological_association\n      };\n    });\n\n    // Generate astrological insights if requested\n    let astrologicalInsights = null;\n    let planetaryInfluences = null;\n    let cosmicTiming = null;\n\n    if (includeAstrology) {\n      try {\n        // Initialize AstrologyGuru\n        const astrologyGuru = new AstrologyGuruAgent();\n        \n        // Get current planetary positions\n        const currentDate = new Date();\n        const ephemerisData = await SwissEphemerisShim.calculateFullChart({\n          name: 'Current Transit',\n          date: currentDate,\n          city: 'GMT',\n          country: 'Universal',\n          latitude: birthData?.latitude || 0,\n          longitude: birthData?.longitude || 0,\n          timezone: birthData?.timezone || 'UTC'\n        });\n\n        // Generate planetary context for reading\n        planetaryInfluences = {\n          moonPhase: calculateMoonPhase(ephemerisData),\n          mercuryRetrograde: ephemerisData.planets.find(p => p.name === 'Mercury')?.speed < 0,\n          dominantPlanets: ephemerisData.planets\n            .filter(p => ['Sun', 'Moon', 'Mercury', 'Venus', 'Mars'].includes(p.name))\n            .map(p => ({\n              planet: p.name,\n              sign: p.sign,\n              house: p.house,\n              retrograde: p.speed < 0\n            }))\n        };\n\n        // Generate cosmic timing advice\n        cosmicTiming = {\n          favorable: planetaryInfluences.mercuryRetrograde ? 'reflection' : 'action',\n          moonPhaseAdvice: getMoonPhaseAdvice(planetaryInfluences.moonPhase),\n          bestTiming: 'Next 3-5 days for implementation'\n        };\n\n        // Create hybrid insights for each card\n        astrologicalInsights = await Promise.all(drawnCards.map(async (card) => {\n          const planetaryConnection = mapCardToPlanet(card);\n          const elementalEnergy = getElementalEnergy(card, ephemerisData);\n          \n          return {\n            cardId: card.id,\n            position: card.position,\n            planetaryRuler: planetaryConnection,\n            elementalBalance: elementalEnergy,\n            cosmicMessage: generateCosmicMessage(card, planetaryInfluences),\n            timingAdvice: getCardTimingAdvice(card, planetaryInfluences)\n          };\n        }));\n\n      } catch (astroError) {\n        logger.warn('astrology_integration_error', user_id, {}, astroError as Error, 'Astrology integration failed, continuing without');\n        // Continue without astrological insights\n      }\n    }\n\n    const drawId = `draw_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const fetchTime = Date.now() - startTime;\n\n    // Build enhanced response\n    const response = {\n      success: true,\n      data: {\n        cards: drawnCards,\n        astrology: includeAstrology ? {\n          insights: astrologicalInsights,\n          planetaryInfluences,\n          cosmicTiming,\n          interpretationGuide: {\n            synthesis: 'Combine tarot wisdom with cosmic influences',\n            focus: planetaryInfluences?.mercuryRetrograde ? 'inner reflection' : 'external action'\n          }\n        } : null,\n        metadata: {\n          drawId,\n          deckId,\n          deckName: deckData.name,\n          spreadType: spread_type,\n          timestamp: new Date().toISOString(),\n          cardCount: drawnCards.length,\n          allowReversed,\n          user_id: user_id || null,\n          includesAstrology: includeAstrology\n        },\n        performance: {\n          fetchTimeMs: fetchTime,\n          cardsFetched: cardData.length,\n          cardsDrawn: drawnCards.length\n        }\n      }\n    };\n\n    logger.info('tarot_draw_enhanced', user_id, {\n      spread_type,\n      deckId,\n      drawId,\n      includeAstrology\n    }, `Enhanced draw: ${drawnCards.length} cards with ${includeAstrology ? 'astrology' : 'no astrology'}`);\n\n    return NextResponse.json(response, {\n      headers: {\n        'Cache-Control': 'no-cache, no-store, must-revalidate',\n        'X-Draw-Time': fetchTime.toString(),\n        'X-Draw-ID': drawId,\n        'X-Enhanced': 'true'\n      }\n    });\n\n  } catch (error) {\n    logger.error('tarot_draw_enhanced_error', undefined, {}, error as Error, 'Enhanced draw failed');\n    return NextResponse.json({\n      success: false,\n      error: 'Internal server error',\n      code: 'INTERNAL_ERROR',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  }\n}\n\n// Helper functions\nfunction calculateMoonPhase(ephemerisData: any): string {\n  const moon = ephemerisData.planets.find(p => p.name === 'Moon');\n  const sun = ephemerisData.planets.find(p => p.name === 'Sun');\n  if (!moon || !sun) return 'unknown';\n  \n  let angle = moon.longitude - sun.longitude;\n  if (angle < 0) angle += 360;\n  \n  if (angle < 45) return 'new';\n  if (angle < 90) return 'waxing_crescent';\n  if (angle < 135) return 'first_quarter';\n  if (angle < 180) return 'waxing_gibbous';\n  if (angle < 225) return 'full';\n  if (angle < 270) return 'waning_gibbous';\n  if (angle < 315) return 'last_quarter';\n  return 'waning_crescent';\n}\n\nfunction getMoonPhaseAdvice(phase: string): string {\n  const advice = {\n    'new': 'Perfect for new beginnings and setting intentions',\n    'waxing_crescent': 'Take action on your plans',\n    'first_quarter': 'Push through challenges',\n    'waxing_gibbous': 'Refine and adjust your approach',\n    'full': 'Manifestation and release',\n    'waning_gibbous': 'Express gratitude and share wisdom',\n    'last_quarter': 'Release what no longer serves',\n    'waning_crescent': 'Rest and reflect',\n    'unknown': 'Trust your intuition'\n  };\n  return advice[phase] || advice.unknown;\n}\n\nfunction mapCardToPlanet(card: any): string {\n  // Map Major Arcana to planets\n  const planetMap = {\n    'The Fool': 'Uranus',\n    'The Magician': 'Mercury',\n    'The High Priestess': 'Moon',\n    'The Empress': 'Venus',\n    'The Emperor': 'Mars',\n    'The Hierophant': 'Jupiter',\n    'The Lovers': 'Venus',\n    'The Chariot': 'Moon',\n    'Strength': 'Sun',\n    'The Hermit': 'Saturn',\n    'Wheel of Fortune': 'Jupiter',\n    'Justice': 'Venus',\n    'The Hanged Man': 'Neptune',\n    'Death': 'Pluto',\n    'Temperance': 'Jupiter',\n    'The Devil': 'Saturn',\n    'The Tower': 'Mars',\n    'The Star': 'Uranus',\n    'The Moon': 'Moon',\n    'The Sun': 'Sun',\n    'Judgement': 'Pluto',\n    'The World': 'Saturn'\n  };\n  \n  if (card.arcana_type === 'major') {\n    return planetMap[card.name] || 'Jupiter';\n  }\n  \n  // Map suits to elements/planets\n  const suitMap = {\n    'wands': 'Mars',\n    'cups': 'Moon',\n    'swords': 'Mercury',\n    'pentacles': 'Venus'\n  };\n  \n  return suitMap[card.suit?.toLowerCase()] || 'Earth';\n}\n\nfunction getElementalEnergy(card: any, ephemerisData: any): string {\n  const element = card.elemental_association || 'earth';\n  const elementCount = ephemerisData.planets.filter(p => {\n    const signElement = getSignElement(p.sign);\n    return signElement === element.toLowerCase();\n  }).length;\n  \n  if (elementCount >= 3) return `Strong ${element} energy`;\n  if (elementCount >= 2) return `Moderate ${element} energy`;\n  return `Subtle ${element} energy`;\n}\n\nfunction getSignElement(sign: string): string {\n  const elements = {\n    'Aries': 'fire', 'Leo': 'fire', 'Sagittarius': 'fire',\n    'Taurus': 'earth', 'Virgo': 'earth', 'Capricorn': 'earth',\n    'Gemini': 'air', 'Libra': 'air', 'Aquarius': 'air',\n    'Cancer': 'water', 'Scorpio': 'water', 'Pisces': 'water'\n  };\n  return elements[sign] || 'earth';\n}\n\nfunction generateCosmicMessage(card: any, planetaryInfluences: any): string {\n  const isRetrograde = planetaryInfluences?.mercuryRetrograde;\n  const moonPhase = planetaryInfluences?.moonPhase;\n  \n  let message = `${card.name} appears during ${moonPhase} moon`;\n  if (isRetrograde) {\n    message += ', suggesting inner reflection on ' + (card.keywords?.[0] || 'this theme');\n  } else {\n    message += ', encouraging action on ' + (card.keywords?.[0] || 'this theme');\n  }\n  \n  return message;\n}\n\nfunction getCardTimingAdvice(card: any, planetaryInfluences: any): string {\n  if (card.arcana_type === 'major') {\n    return 'Significant life theme unfolding over weeks/months';\n  }\n  \n  const suitTiming = {\n    'wands': 'Days to weeks - swift energy',\n    'cups': 'Weeks to months - emotional cycles',\n    'swords': 'Immediate to days - mental clarity needed',\n    'pentacles': 'Months to years - long-term manifestation'\n  };\n  \n  return suitTiming[card.suit?.toLowerCase()] || 'Trust divine timing';\n}"
    },
    {
      "endpoint": "/api/tarot/shuffle",
      "method": "POST",
      "description": "Enhanced shuffle endpoint with cosmic randomization",
      "code": "import { NextRequest, NextResponse } from 'next/server';\nimport { createClient } from '@/lib/supabase/server';\nimport Logger from '@/utils/logger';\nimport { SwissEphemerisShim } from '@/lib/astrology/SwissEphemerisShim';\n\nconst logger = new Logger('tarot-shuffle-enhanced');\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const {\n      deckId = '00000000-0000-0000-0000-000000000001',\n      algorithm = 'cosmic-fisher-yates', // New default: cosmic-enhanced\n      includePreview = true,\n      user_id,\n      cosmicSeed = true // Use planetary positions for entropy\n    } = body;\n\n    // Validate algorithm\n    const validAlgorithms = ['fisher-yates', 'riffle', 'overhand', 'cosmic-fisher-yates', 'quantum'];\n    if (!validAlgorithms.includes(algorithm)) {\n      return NextResponse.json({\n        success: false,\n        error: 'Invalid shuffle algorithm',\n        code: 'INVALID_ALGORITHM',\n        validAlgorithms\n      }, { status: 400 });\n    }\n\n    // Initialize Supabase\n    const supabase = await createClient();\n\n    // Fetch deck cards\n    const startTime = Date.now();\n    const { data: cards, error: fetchError } = await supabase\n      .from('cards')\n      .select('*')\n      .eq('deck_id', deckId)\n      .order('card_number');\n\n    if (fetchError || !cards || cards.length === 0) {\n      logger.error('deck_fetch_error', user_id, { deckId }, fetchError || undefined, 'Failed to fetch deck');\n      return NextResponse.json({\n        success: false,\n        error: `No cards found for deck ${deckId}`,\n        code: 'DECK_NOT_FOUND'\n      }, { status: 404 });\n    }\n\n    // Get cosmic entropy if requested\n    let cosmicEntropy = 1.0;\n    let planetaryPositions = null;\n    \n    if (cosmicSeed) {\n      try {\n        const ephemerisData = await SwissEphemerisShim.calculateFullChart({\n          name: 'Cosmic Shuffle',\n          date: new Date(),\n          city: 'GMT',\n          country: 'Universal',\n          latitude: 0,\n          longitude: 0,\n          timezone: 'UTC'\n        });\n\n        // Use planetary positions to influence randomization\n        planetaryPositions = ephemerisData.planets.map(p => ({\n          planet: p.name,\n          degree: p.longitude,\n          speed: p.speed\n        }));\n\n        // Calculate cosmic entropy from planetary speeds\n        cosmicEntropy = planetaryPositions.reduce((sum, p) => {\n          return sum + Math.abs(p.speed) / 10;\n        }, 0) / planetaryPositions.length;\n\n      } catch (ephemError) {\n        logger.warn('cosmic_entropy_error', user_id, {}, ephemError as Error, 'Failed to get cosmic entropy');\n      }\n    }\n\n    // Perform shuffle based on algorithm\n    const shuffledCards = performEnhancedShuffle(cards, algorithm, cosmicEntropy);\n    const shuffleTime = Date.now() - startTime;\n\n    // Generate shuffle ID and calculate entropy\n    const shuffleId = `shuffle_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const entropy = calculateShuffleEntropy(shuffledCards, cosmicEntropy);\n\n    const shuffleState = {\n      algorithm,\n      timestamp: new Date().toISOString(),\n      entropy: Math.round(entropy * 100) / 100,\n      cosmicInfluence: cosmicSeed ? cosmicEntropy : null,\n      planetaryAlignment: cosmicSeed ? calculatePlanetaryAlignment(planetaryPositions) : null\n    };\n\n    // Enhanced preview with cosmic significance\n    let preview = null;\n    if (includePreview && shuffledCards.length >= 3) {\n      const topCard = shuffledCards[0];\n      const middleCard = shuffledCards[Math.floor(shuffledCards.length / 2)];\n      const bottomCard = shuffledCards[shuffledCards.length - 1];\n\n      preview = {\n        topCard: {\n          name: topCard.name,\n          arcana: topCard.arcana_type,\n          suit: topCard.suit,\n          cosmicMessage: cosmicSeed ? getCardCosmicMessage(topCard, planetaryPositions) : null\n        },\n        middleCard: {\n          name: middleCard.name,\n          arcana: middleCard.arcana_type,\n          suit: middleCard.suit,\n          cosmicMessage: cosmicSeed ? getCardCosmicMessage(middleCard, planetaryPositions) : null\n        },\n        bottomCard: {\n          name: bottomCard.name,\n          arcana: bottomCard.arcana_type,\n          suit: bottomCard.suit,\n          cosmicMessage: cosmicSeed ? getCardCosmicMessage(bottomCard, planetaryPositions) : null\n        },\n        shuffleQuality: entropy > 0.7 ? 'Excellent' : entropy > 0.4 ? 'Good' : 'Fair'\n      };\n    }\n\n    // Store shuffle state in session/cache for subsequent draws\n    if (user_id) {\n      // Store shuffle state for user session\n      await storeShuffleState(supabase, user_id, shuffleId, shuffledCards.map(c => c.id));\n    }\n\n    const response = {\n      success: true,\n      shuffleId,\n      deckId,\n      cardCount: shuffledCards.length,\n      shuffleState,\n      preview,\n      performance: {\n        shuffleTimeMs: shuffleTime,\n        entropyScore: entropy,\n        cosmicInfluence: cosmicSeed\n      }\n    };\n\n    logger.info('tarot_shuffle_enhanced', user_id, {\n      deckId,\n      algorithm,\n      cardCount: shuffledCards.length,\n      shuffleTime,\n      entropy,\n      cosmicSeed,\n      shuffleId\n    }, `Enhanced shuffle completed with ${algorithm}`);\n\n    return NextResponse.json(response, {\n      headers: {\n        'Cache-Control': 'no-cache, no-store, must-revalidate',\n        'X-Shuffle-Time': shuffleTime.toString(),\n        'X-Shuffle-ID': shuffleId,\n        'X-Entropy': entropy.toString(),\n        'X-Cosmic-Seed': cosmicSeed.toString()\n      }\n    });\n\n  } catch (error) {\n    logger.error('tarot_shuffle_enhanced_error', undefined, {}, error as Error, 'Enhanced shuffle failed');\n    return NextResponse.json({\n      success: false,\n      error: 'Internal server error',\n      code: 'INTERNAL_ERROR',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  }\n}\n\n// Enhanced shuffle algorithms\nfunction performEnhancedShuffle(cards: any[], algorithm: string, cosmicEntropy: number): any[] {\n  switch (algorithm) {\n    case 'cosmic-fisher-yates':\n      return cosmicFisherYatesShuffle(cards, cosmicEntropy);\n    case 'quantum':\n      return quantumShuffle(cards, cosmicEntropy);\n    case 'fisher-yates':\n      return fisherYatesShuffle(cards);\n    case 'riffle':\n      return riffleShuffle(cards);\n    case 'overhand':\n      return overhandShuffle(cards);\n    default:\n      return fisherYatesShuffle(cards);\n  }\n}\n\n// Cosmic-enhanced Fisher-Yates\nfunction cosmicFisherYatesShuffle(array: any[], cosmicEntropy: number): any[] {\n  const shuffled = [...array];\n  const cosmicFactor = 0.3 + (cosmicEntropy * 0.7); // 30-100% cosmic influence\n  \n  for (let i = shuffled.length - 1; i > 0; i--) {\n    // Standard random with cosmic influence\n    const standardRandom = Math.random();\n    const cosmicRandom = (Math.sin(cosmicEntropy * i * Math.PI) + 1) / 2;\n    const finalRandom = standardRandom * (1 - cosmicFactor) + cosmicRandom * cosmicFactor;\n    \n    const j = Math.floor(finalRandom * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n  }\n  \n  return shuffled;\n}\n\n// Quantum-inspired shuffle (simulated)\nfunction quantumShuffle(array: any[], cosmicEntropy: number): any[] {\n  const shuffled = [...array];\n  const iterations = 3 + Math.floor(cosmicEntropy * 4); // 3-7 iterations\n  \n  for (let iter = 0; iter < iterations; iter++) {\n    // Create quantum superposition pairs\n    for (let i = 0; i < shuffled.length - 1; i += 2) {\n      if (Math.random() < 0.5 + cosmicEntropy * 0.2) {\n        // Quantum entanglement swap\n        [shuffled[i], shuffled[i + 1]] = [shuffled[i + 1], shuffled[i]];\n      }\n    }\n    \n    // Collapse wave function with cosmic influence\n    shuffled.sort(() => {\n      const quantum = Math.sin(Date.now() * cosmicEntropy) * 0.5;\n      return Math.random() - 0.5 + quantum;\n    });\n  }\n  \n  return shuffled;\n}\n\n// Standard algorithms (kept for compatibility)\nfunction fisherYatesShuffle(array: any[]): any[] {\n  const shuffled = [...array];\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n  }\n  return shuffled;\n}\n\nfunction riffleShuffle(array: any[]): any[] {\n  const deck = [...array];\n  const mid = Math.floor(deck.length / 2);\n  const left = deck.slice(0, mid);\n  const right = deck.slice(mid);\n  const shuffled: any[] = [];\n  \n  let i = 0, j = 0;\n  while (i < left.length && j < right.length) {\n    if (Math.random() < 0.6) {\n      shuffled.push(left[i++]);\n    } else {\n      shuffled.push(right[j++]);\n    }\n  }\n  \n  shuffled.push(...left.slice(i), ...right.slice(j));\n  return shuffled;\n}\n\nfunction overhandShuffle(array: any[]): any[] {\n  let deck = [...array];\n  const passes = 3 + Math.floor(Math.random() * 3);\n  \n  for (let pass = 0; pass < passes; pass++) {\n    const newDeck: any[] = [];\n    while (deck.length > 0) {\n      const packetSize = Math.min(deck.length, 1 + Math.floor(Math.random() * 6));\n      const packet = deck.splice(0, packetSize);\n      newDeck.unshift(...packet);\n    }\n    deck = newDeck;\n  }\n  \n  return deck;\n}\n\n// Calculate enhanced entropy with cosmic influence\nfunction calculateShuffleEntropy(shuffledCards: any[], cosmicEntropy: number): number {\n  let entropy = 0;\n  const cardCount = shuffledCards.length;\n  \n  // Position displacement entropy\n  for (let i = 0; i < cardCount; i++) {\n    const originalPosition = shuffledCards[i].card_number;\n    const displacement = Math.abs(i - originalPosition);\n    entropy += displacement / cardCount;\n  }\n  \n  // Normalize and add cosmic influence\n  entropy = (entropy / cardCount) * 0.7 + cosmicEntropy * 0.3;\n  \n  return Math.min(1, entropy); // Cap at 1.0\n}\n\n// Calculate planetary alignment score\nfunction calculatePlanetaryAlignment(planetaryPositions: any[]): string {\n  if (!planetaryPositions) return 'Unknown';\n  \n  // Count planets in same element\n  const elements = planetaryPositions.map(p => {\n    const degree = p.degree;\n    const sign = Math.floor(degree / 30);\n    const signElements = [2, 0, 1, 3, 2, 0, 1, 3, 2, 0, 1, 3]; // F,E,A,W pattern\n    return signElements[sign];\n  });\n  \n  const elementCounts = [0, 0, 0, 0]; // Fire, Earth, Air, Water\n  elements.forEach(e => elementCounts[e]++);\n  const maxElement = Math.max(...elementCounts);\n  \n  if (maxElement >= 5) return 'Strong elemental focus';\n  if (maxElement >= 3) return 'Moderate alignment';\n  return 'Balanced energies';\n}\n\n// Get cosmic message for preview cards\nfunction getCardCosmicMessage(card: any, planetaryPositions: any[]): string {\n  if (!planetaryPositions) return 'Trust the shuffle';\n  \n  // Find dominant planet by speed\n  const fastestPlanet = planetaryPositions.reduce((fastest, p) => {\n    return Math.abs(p.speed) > Math.abs(fastest.speed) ? p : fastest;\n  });\n  \n  const messages = {\n    'major': `${fastestPlanet.planet} activates ${card.name}'s transformative power`,\n    'wands': `Fire energy aligned with ${fastestPlanet.planet} for swift action`,\n    'cups': `Emotional tides flow with ${fastestPlanet.planet}'s influence`,\n    'swords': `Mental clarity sharpened by ${fastestPlanet.planet}'s precision`,\n    'pentacles': `Material manifestation supported by ${fastestPlanet.planet}'s grounding`\n  };\n  \n  const key = card.arcana_type === 'major' ? 'major' : card.suit?.toLowerCase();\n  return messages[key] || 'Cosmic alignment supports this draw';\n}\n\n// Store shuffle state for user session\nasync function storeShuffleState(supabase: any, userId: string, shuffleId: string, cardOrder: string[]): Promise<void> {\n  try {\n    // Store in a session table or cache\n    await supabase\n      .from('user_shuffle_states')\n      .upsert({\n        user_id: userId,\n        shuffle_id: shuffleId,\n        card_order: cardOrder,\n        created_at: new Date().toISOString(),\n        expires_at: new Date(Date.now() + 3600000).toISOString() // 1 hour expiry\n      }, {\n        onConflict: 'user_id'\n      });\n  } catch (error) {\n    // Non-critical error, log but don't fail the shuffle\n    logger.warn('shuffle_state_store_error', userId, { shuffleId }, error as Error, 'Failed to store shuffle state');\n  }\n}"
    },
    {
      "endpoint": "/api/tarot/save-reading",
      "method": "POST",
      "description": "Enhanced save-reading endpoint with hybrid astrology data",
      "code": "import { NextRequest, NextResponse } from 'next/server';\nimport { createClient } from '@/lib/supabase/server';\nimport Logger from '@/utils/logger';\nimport { z } from 'zod';\n\nconst logger = new Logger('tarot-save-enhanced');\n\n// Enhanced validation schema\nconst SaveReadingSchema = z.object({\n  user_id: z.string().uuid('Invalid user_id format'),\n  spreadType: z.enum(['single', '3-card', '5-card', '7-card', 'celtic-cross']),\n  cards: z.array(z.object({\n    id: z.string(),\n    name: z.string(),\n    position: z.string(),\n    isReversed: z.boolean(),\n    meaning: z.string().optional(),\n    interpretation: z.string().optional(),\n    astrological_association: z.string().optional()\n  })).min(1).max(10),\n  interpretation: z.string().min(10, 'Interpretation must be at least 10 characters'),\n  question: z.string().optional(),\n  notes: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  isPublic: z.boolean().default(false),\n  drawId: z.string().optional(),\n  // New hybrid fields\n  cosmicInfluence: z.object({\n    moonPhase: z.string().optional(),\n    planetaryPositions: z.array(z.object({\n      planet: z.string(),\n      sign: z.string(),\n      degree: z.number(),\n      retrograde: z.boolean()\n    })).optional(),\n    dominantElement: z.string().optional(),\n    cosmicTiming: z.object({\n      favorable: z.string(),\n      advice: z.string()\n    }).optional()\n  }).optional(),\n  astrologicalInsights: z.array(z.object({\n    cardId: z.string(),\n    planetaryRuler: z.string(),\n    elementalBalance: z.string(),\n    cosmicMessage: z.string(),\n    timingAdvice: z.string()\n  })).optional(),\n  readingType: z.enum(['tarot', 'astrology', 'hybrid']).default('tarot'),\n  birthData: z.object({\n    date: z.string(),\n    time: z.string().optional(),\n    location: z.string().optional(),\n    timezone: z.string().optional()\n  }).optional()\n});\n\nexport async function POST(request: NextRequest) {\n  const startTime = Date.now();\n  \n  try {\n    // Get authorization header\n    const authorization = request.headers.get('authorization');\n    if (!authorization || !authorization.startsWith('Bearer ')) {\n      return NextResponse.json({\n        success: false,\n        error: 'Authentication required',\n        code: 'UNAUTHENTICATED'\n      }, { status: 401 });\n    }\n\n    const token = authorization.split(' ')[1];\n    \n    // Parse and validate request body\n    const body = await request.json();\n    const validationResult = SaveReadingSchema.safeParse(body);\n    \n    if (!validationResult.success) {\n      return NextResponse.json({\n        success: false,\n        error: 'Validation failed',\n        code: 'VALIDATION_ERROR',\n        details: validationResult.error.format()\n      }, { status: 400 });\n    }\n\n    const validatedData = validationResult.data;\n\n    // Initialize Supabase with user token\n    const supabase = await createClient();\n    \n    // Verify authentication\n    const { data: { user }, error: authError } = await supabase.auth.getUser(token);\n    \n    if (authError || !user) {\n      logger.warn('save_reading_auth_error', undefined, { error: authError?.message }, 'Authentication failed');\n      return NextResponse.json({\n        success: false,\n        error: 'Authentication failed',\n        code: 'AUTH_ERROR'\n      }, { status: 401 });\n    }\n\n    // Verify user_id matches authenticated user\n    if (validatedData.user_id !== user.id) {\n      return NextResponse.json({\n        success: false,\n        error: 'User ID mismatch',\n        code: 'USER_MISMATCH'\n      }, { status: 403 });\n    }\n\n    // Validate card count matches spread type\n    const expectedCardCounts = {\n      'single': 1,\n      '3-card': 3,\n      '5-card': 5,\n      '7-card': 7,\n      'celtic-cross': 10\n    };\n\n    const expectedCount = expectedCardCounts[validatedData.spreadType];\n    if (validatedData.cards.length !== expectedCount) {\n      return NextResponse.json({\n        success: false,\n        error: `${validatedData.spreadType} requires exactly ${expectedCount} cards`,\n        code: 'CARD_COUNT_MISMATCH'\n      }, { status: 400 });\n    }\n\n    // Check user's reading quota\n    const quotaCheck = await checkUserQuota(supabase, user.id);\n    if (!quotaCheck.allowed) {\n      return NextResponse.json({\n        success: false,\n        error: quotaCheck.message,\n        code: 'QUOTA_EXCEEDED',\n        quotaInfo: quotaCheck.info\n      }, { status: 429 });\n    }\n\n    // Prepare enhanced reading data\n    const readingData = {\n      user_id: user.id,\n      spread_type: validatedData.spreadType,\n      reading_type: validatedData.readingType,\n      cards_drawn: {\n        cards: validatedData.cards.map(card => ({\n          ...card,\n          savedAt: new Date().toISOString()\n        })),\n        positions: validatedData.cards.map(c => c.position),\n        count: validatedData.cards.length\n      },\n      interpretation_text: validatedData.interpretation,\n      question: validatedData.question || null,\n      notes: validatedData.notes || null,\n      tags: validatedData.tags || [],\n      is_public: validatedData.isPublic,\n      draw_id: validatedData.drawId || null,\n      // Enhanced hybrid fields\n      cosmic_influence: validatedData.cosmicInfluence || null,\n      astrological_insights: validatedData.astrologicalInsights || null,\n      birth_data: validatedData.birthData || null,\n      metadata: {\n        version: '2.0',\n        client: request.headers.get('user-agent') || 'unknown',\n        savedAt: new Date().toISOString(),\n        enhancedFeatures: {\n          hasAstrology: !!validatedData.cosmicInfluence,\n          hasInsights: !!validatedData.astrologicalInsights,\n          hasBirthData: !!validatedData.birthData\n        }\n      }\n    };\n\n    // Save to database with transaction\n    const { data: savedReading, error: saveError } = await supabase\n      .from('tarot_readings')\n      .insert([readingData])\n      .select('id, created_at')\n      .single();\n\n    if (saveError) {\n      logger.error('save_reading_db_error', user.id, { spreadType: validatedData.spreadType }, saveError, 'Database save failed');\n      return NextResponse.json({\n        success: false,\n        error: 'Failed to save reading',\n        code: 'SAVE_ERROR',\n        details: saveError.message\n      }, { status: 500 });\n    }\n\n    // Update user statistics\n    await updateUserStats(supabase, user.id, validatedData.spreadType, validatedData.readingType);\n\n    // If public, add to community feed\n    if (validatedData.isPublic) {\n      await addToCommunityFeed(supabase, savedReading.id, user.id, validatedData);\n    }\n\n    const saveTime = Date.now() - startTime;\n\n    // Build success response\n    const response = {\n      success: true,\n      data: {\n        readingId: savedReading.id,\n        savedAt: savedReading.created_at,\n        user_id: user.id,\n        spreadType: validatedData.spreadType,\n        readingType: validatedData.readingType,\n        cardCount: validatedData.cards.length,\n        isPublic: validatedData.isPublic,\n        hasAstrology: !!validatedData.cosmicInfluence,\n        shareUrl: validatedData.isPublic ? `/readings/${savedReading.id}` : null\n      },\n      performance: {\n        saveTimeMs: saveTime\n      }\n    };\n\n    // Analytics logging\n    logger.info('tarot_reading_saved_enhanced', user.id, {\n      readingId: savedReading.id,\n      spreadType: validatedData.spreadType,\n      readingType: validatedData.readingType,\n      cardCount: validatedData.cards.length,\n      hasQuestion: !!validatedData.question,\n      hasTags: (validatedData.tags?.length || 0) > 0,\n      hasAstrology: !!validatedData.cosmicInfluence,\n      isPublic: validatedData.isPublic,\n      saveTime\n    }, `Enhanced reading saved: ${savedReading.id}`);\n\n    return NextResponse.json(response, {\n      headers: {\n        'X-Save-Time': saveTime.toString(),\n        'X-Reading-ID': savedReading.id,\n        'X-Reading-Type': validatedData.readingType\n      },\n      status: 201\n    });\n\n  } catch (error) {\n    logger.error('save_reading_enhanced_error', undefined, {}, error as Error, 'Failed to save enhanced reading');\n    \n    if (error instanceof z.ZodError) {\n      return NextResponse.json({\n        success: false,\n        error: 'Invalid request data',\n        code: 'VALIDATION_ERROR',\n        details: error.errors\n      }, { status: 400 });\n    }\n\n    return NextResponse.json({\n      success: false,\n      error: 'Internal server error',\n      code: 'INTERNAL_ERROR',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  }\n}\n\n// Check user's reading quota\nasync function checkUserQuota(supabase: any, userId: string): Promise<{\n  allowed: boolean;\n  message: string;\n  info: any;\n}> {\n  try {\n    // Get user's readings from last 24 hours\n    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();\n    \n    const { data: recentReadings, error } = await supabase\n      .from('tarot_readings')\n      .select('id, created_at')\n      .eq('user_id', userId)\n      .gte('created_at', oneDayAgo)\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      logger.warn('quota_check_error', userId, {}, error, 'Failed to check quota');\n      // Allow on error to not block users\n      return { allowed: true, message: 'Quota check bypassed', info: {} };\n    }\n\n    const dailyCount = recentReadings?.length || 0;\n    const dailyLimit = 50; // Configurable limit\n\n    if (dailyCount >= dailyLimit) {\n      return {\n        allowed: false,\n        message: `Daily reading limit (${dailyLimit}) reached`,\n        info: {\n          dailyCount,\n          dailyLimit,\n          resetTime: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\n        }\n      };\n    }\n\n    // Check monthly limit\n    const oneMonthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();\n    \n    const { data: monthlyReadings } = await supabase\n      .from('tarot_readings')\n      .select('id')\n      .eq('user_id', userId)\n      .gte('created_at', oneMonthAgo);\n\n    const monthlyCount = monthlyReadings?.length || 0;\n    const monthlyLimit = 500;\n\n    if (monthlyCount >= monthlyLimit) {\n      return {\n        allowed: false,\n        message: `Monthly reading limit (${monthlyLimit}) reached`,\n        info: {\n          monthlyCount,\n          monthlyLimit,\n          resetTime: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()\n        }\n      };\n    }\n\n    return {\n      allowed: true,\n      message: 'Within quota limits',\n      info: {\n        dailyCount,\n        dailyLimit,\n        monthlyCount,\n        monthlyLimit,\n        dailyRemaining: dailyLimit - dailyCount,\n        monthlyRemaining: monthlyLimit - monthlyCount\n      }\n    };\n\n  } catch (error) {\n    logger.error('quota_check_error', userId, {}, error as Error, 'Quota check failed');\n    // Allow on error\n    return { allowed: true, message: 'Quota check error', info: {} };\n  }\n}\n\n// Update user statistics\nasync function updateUserStats(supabase: any, userId: string, spreadType: string, readingType: string): Promise<void> {\n  try {\n    // Increment user stats\n    const { error } = await supabase.rpc('increment_user_stats', {\n      p_user_id: userId,\n      p_spread_type: spreadType,\n      p_reading_type: readingType\n    });\n\n    if (error) {\n      logger.warn('update_stats_error', userId, { spreadType, readingType }, error, 'Failed to update user stats');\n    }\n  } catch (error) {\n    // Non-critical error\n    logger.warn('update_stats_error', userId, {}, error as Error, 'Stats update failed');\n  }\n}\n\n// Add reading to community feed if public\nasync function addToCommunityFeed(supabase: any, readingId: string, userId: string, data: any): Promise<void> {\n  try {\n    const feedEntry = {\n      reading_id: readingId,\n      user_id: userId,\n      spread_type: data.spreadType,\n      card_names: data.cards.map((c: any) => c.name),\n      has_question: !!data.question,\n      tags: data.tags || [],\n      created_at: new Date().toISOString()\n    };\n\n    const { error } = await supabase\n      .from('community_feed')\n      .insert([feedEntry]);\n\n    if (error) {\n      logger.warn('community_feed_error', userId, { readingId }, error, 'Failed to add to community feed');\n    }\n  } catch (error) {\n    // Non-critical error\n    logger.warn('community_feed_error', userId, {}, error as Error, 'Community feed update failed');\n  }\n}\n\n// GET endpoint for retrieving saved readings\nexport async function GET(request: NextRequest) {\n  const { searchParams } = new URL(request.url);\n  const readingId = searchParams.get('id');\n  const userId = searchParams.get('user_id');\n  const limit = parseInt(searchParams.get('limit') || '10');\n  const offset = parseInt(searchParams.get('offset') || '0');\n  const filterType = searchParams.get('type'); // tarot, astrology, hybrid\n  \n  try {\n    const supabase = await createClient();\n\n    // Get specific reading by ID\n    if (readingId) {\n      const { data: reading, error } = await supabase\n        .from('tarot_readings')\n        .select('*')\n        .eq('id', readingId)\n        .single();\n\n      if (error || !reading) {\n        return NextResponse.json({\n          success: false,\n          error: 'Reading not found',\n          code: 'NOT_FOUND'\n        }, { status: 404 });\n      }\n\n      // Check access permissions\n      if (!reading.is_public && reading.user_id !== userId) {\n        return NextResponse.json({\n          success: false,\n          error: 'Access denied',\n          code: 'FORBIDDEN'\n        }, { status: 403 });\n      }\n\n      return NextResponse.json({\n        success: true,\n        data: reading\n      });\n    }\n\n    // Get user's readings list\n    if (userId) {\n      let query = supabase\n        .from('tarot_readings')\n        .select('id, spread_type, reading_type, created_at, cards_drawn, question, tags, is_public')\n        .eq('user_id', userId)\n        .order('created_at', { ascending: false })\n        .range(offset, offset + limit - 1);\n\n      if (filterType) {\n        query = query.eq('reading_type', filterType);\n      }\n\n      const { data: readings, error, count } = await query;\n\n      if (error) {\n        logger.error('get_readings_error', userId, { limit, offset }, error, 'Failed to fetch readings');\n        return NextResponse.json({\n          success: false,\n          error: 'Failed to fetch readings',\n          code: 'FETCH_ERROR'\n        }, { status: 500 });\n      }\n\n      return NextResponse.json({\n        success: true,\n        data: {\n          readings: readings || [],\n          pagination: {\n            total: count || 0,\n            limit,\n            offset,\n            hasMore: (count || 0) > offset + limit\n          }\n        }\n      });\n    }\n\n    return NextResponse.json({\n      success: false,\n      error: 'user_id or id parameter required',\n      code: 'MISSING_PARAMS'\n    }, { status: 400 });\n\n  } catch (error) {\n    logger.error('get_readings_error', undefined, {}, error as Error, 'Failed to get readings');\n    return NextResponse.json({\n      success: false,\n      error: 'Internal server error',\n      code: 'INTERNAL_ERROR'\n    }, { status: 500 });\n  }\n}"
    }
  ],
  "database_schema": {
    "description": "Required database tables for enhanced tarot system",
    "tables": [
      {
        "name": "tarot_readings",
        "columns": [
          "id UUID PRIMARY KEY DEFAULT uuid_generate_v4()",
          "user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE",
          "spread_type VARCHAR(50) NOT NULL",
          "reading_type VARCHAR(20) DEFAULT 'tarot'",
          "cards_drawn JSONB NOT NULL",
          "interpretation_text TEXT NOT NULL",
          "question TEXT",
          "notes TEXT",
          "tags TEXT[]",
          "is_public BOOLEAN DEFAULT false",
          "draw_id VARCHAR(100)",
          "cosmic_influence JSONB",
          "astrological_insights JSONB",
          "birth_data JSONB",
          "metadata JSONB",
          "created_at TIMESTAMPTZ DEFAULT NOW()",
          "updated_at TIMESTAMPTZ DEFAULT NOW()"
        ],
        "indexes": [
          "CREATE INDEX idx_tarot_readings_user_id ON tarot_readings(user_id)",
          "CREATE INDEX idx_tarot_readings_spread_type ON tarot_readings(spread_type)",
          "CREATE INDEX idx_tarot_readings_reading_type ON tarot_readings(reading_type)",
          "CREATE INDEX idx_tarot_readings_is_public ON tarot_readings(is_public)",
          "CREATE INDEX idx_tarot_readings_created_at ON tarot_readings(created_at DESC)"
        ]
      },
      {
        "name": "user_shuffle_states",
        "columns": [
          "id UUID PRIMARY KEY DEFAULT uuid_generate_v4()",
          "user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE",
          "shuffle_id VARCHAR(100) NOT NULL",
          "card_order TEXT[] NOT NULL",
          "created_at TIMESTAMPTZ DEFAULT NOW()",
          "expires_at TIMESTAMPTZ NOT NULL"
        ],
        "indexes": [
          "CREATE UNIQUE INDEX idx_user_shuffle_states_user_id ON user_shuffle_states(user_id)",
          "CREATE INDEX idx_user_shuffle_states_expires_at ON user_shuffle_states(expires_at)"
        ]
      },
      {
        "name": "community_feed",
        "columns": [
          "id UUID PRIMARY KEY DEFAULT uuid_generate_v4()",
          "reading_id UUID REFERENCES tarot_readings(id) ON DELETE CASCADE",
          "user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE",
          "spread_type VARCHAR(50)",
          "card_names TEXT[]",
          "has_question BOOLEAN DEFAULT false",
          "tags TEXT[]",
          "created_at TIMESTAMPTZ DEFAULT NOW()"
        ],
        "indexes": [
          "CREATE INDEX idx_community_feed_created_at ON community_feed(created_at DESC)",
          "CREATE INDEX idx_community_feed_tags ON community_feed USING GIN(tags)"
        ]
      }
    ],
    "rpc_functions": [
      {
        "name": "increment_user_stats",
        "sql": "CREATE OR REPLACE FUNCTION increment_user_stats(\n  p_user_id UUID,\n  p_spread_type VARCHAR(50),\n  p_reading_type VARCHAR(20)\n)\nRETURNS VOID AS $$\nBEGIN\n  INSERT INTO user_stats (user_id, total_readings, readings_by_type)\n  VALUES (p_user_id, 1, jsonb_build_object(p_spread_type, 1, p_reading_type || '_count', 1))\n  ON CONFLICT (user_id) DO UPDATE\n  SET \n    total_readings = user_stats.total_readings + 1,\n    readings_by_type = user_stats.readings_by_type || \n      jsonb_build_object(\n        p_spread_type, COALESCE((user_stats.readings_by_type->>p_spread_type)::int, 0) + 1,\n        p_reading_type || '_count', COALESCE((user_stats.readings_by_type->>(p_reading_type || '_count'))::int, 0) + 1\n      ),\n    updated_at = NOW();\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;"
      }
    ],
    "row_level_security": [
      {
        "table": "tarot_readings",
        "policies": [
          "CREATE POLICY users_can_view_own_readings ON tarot_readings FOR SELECT USING (auth.uid() = user_id)",
          "CREATE POLICY users_can_view_public_readings ON tarot_readings FOR SELECT USING (is_public = true)",
          "CREATE POLICY users_can_insert_own_readings ON tarot_readings FOR INSERT WITH CHECK (auth.uid() = user_id)",
          "CREATE POLICY users_can_update_own_readings ON tarot_readings FOR UPDATE USING (auth.uid() = user_id)",
          "CREATE POLICY users_can_delete_own_readings ON tarot_readings FOR DELETE USING (auth.uid() = user_id)"
        ]
      }
    ]
  },
  "testing": {
    "postman_collection": {
      "name": "Mystic Arcana Tarot API Enhanced",
      "description": "Enhanced tarot endpoints with AstrologyGuru integration",
      "requests": [
        {
          "name": "Draw 3-Card Spread with Astrology",
          "method": "POST",
          "url": "{{base_url}}/api/tarot/draw",
          "headers": {
            "Content-Type": "application/json"
          },
          "body": {
            "spread_type": "3-card",
            "user_id": "{{user_id}}",
            "includeAstrology": true,
            "birthData": {
              "latitude": 40.7128,
              "longitude": -74.006,
              "timezone": "America/New_York"
            }
          }
        },
        {
          "name": "Cosmic Shuffle",
          "method": "POST",
          "url": "{{base_url}}/api/tarot/shuffle",
          "headers": {
            "Content-Type": "application/json"
          },
          "body": {
            "algorithm": "cosmic-fisher-yates",
            "cosmicSeed": true,
            "includePreview": true,
            "user_id": "{{user_id}}"
          }
        },
        {
          "name": "Save Hybrid Reading",
          "method": "POST",
          "url": "{{base_url}}/api/tarot/save-reading",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer {{auth_token}}"
          },
          "body": {
            "user_id": "{{user_id}}",
            "spreadType": "3-card",
            "readingType": "hybrid",
            "cards": [
              {
                "id": "card1",
                "name": "The Fool",
                "position": "Past",
                "isReversed": false
              },
              {
                "id": "card2",
                "name": "The Star",
                "position": "Present",
                "isReversed": true
              },
              {
                "id": "card3",
                "name": "The World",
                "position": "Future",
                "isReversed": false
              }
            ],
            "interpretation": "Your journey from innocence through hope to completion...",
            "question": "What is my spiritual path?",
            "cosmicInfluence": {
              "moonPhase": "waxing_gibbous",
              "dominantElement": "water"
            },
            "tags": ["spiritual", "journey", "transformation"]
          }
        }
      ]
    },
    "n8n_automation": {
      "description": "n8n workflow configuration for tarot analytics",
      "nodes": [
        {
          "name": "Daily Tarot Analytics",
          "type": "Schedule",
          "schedule": "0 2 * * *",
          "timezone": "UTC"
        },
        {
          "name": "Fetch Reading Stats",
          "type": "HTTP Request",
          "method": "GET",
          "url": "{{base_url}}/api/tarot/analytics/daily",
          "authentication": "Bearer Token"
        },
        {
          "name": "Process Stats",
          "type": "Function",
          "code": "const stats = items[0].json;\n\n// Calculate trends\nconst popularSpreads = Object.entries(stats.spreadTypes)\n  .sort(([,a], [,b]) => b - a)\n  .slice(0, 3);\n\nconst hybridPercentage = (stats.readingTypes.hybrid / stats.totalReadings) * 100;\n\nreturn {\n  json: {\n    date: new Date().toISOString().split('T')[0],\n    totalReadings: stats.totalReadings,\n    popularSpreads,\n    hybridAdoption: hybridPercentage.toFixed(2) + '%',\n    peakHour: stats.peakHour,\n    cosmicInfluence: stats.averageCosmicEntropy\n  }\n};"
        },
        {
          "name": "Send to Analytics DB",
          "type": "PostgreSQL",
          "operation": "Insert",
          "table": "tarot_analytics",
          "columns": [
            "date",
            "total_readings",
            "popular_spreads",
            "hybrid_adoption",
            "peak_hour",
            "cosmic_influence"
          ]
        },
        {
          "name": "Notify Admin",
          "type": "Email",
          "to": "admin@mysticarcana.com",
          "subject": "Daily Tarot Analytics Report",
          "body": "Today's tarot reading statistics..."
        }
      ]
    }
  }
}
